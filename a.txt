How JWT Works
User Logs In:

The user provides their username and password.

If the credentials are correct, the server creates a JWT containing user information (e.g., user ID, role) and signs it with a secret key.

Token Sent to Client:

The JWT is sent back to the client, usually stored in the browser (local storage, session storage) or mobile app.

Token Sent with Requests:

For every request to a protected resource, the client includes the JWT in the HTTP header:

Authorization: Bearer <token>

Server Verifies Token:

The server checks the JWT to ensure it hasn’t been tampered with and confirms the user’s identity.
This is a key concept in JWT (JSON Web Token) authentication. Here's how the server validates the JWT:

Structure of JWT: A JWT consists of three parts:

Header: Specifies the algorithm used for signing (e.g., HS256, RS256).

Payload: Contains claims or data, such as user ID or roles.

Signature: Ensures the token's integrity.

Server's Validation Process:

Decoding the JWT: The server decodes the token using the secret key (if using HMAC) or the public key (if using RSA).

Validating the Signature: The server re-generates the signature based on the header and payload using the secret or public key. It compares this with the signature in the JWT to verify that the token hasn’t been altered.

Checking Expiry: The server checks the exp claim to ensure the token is still valid and hasn’t expired.

Validating Claims: The server ensures that required claims (e.g., iss, aud) match expected values.

Confirming User Identity: Once the JWT passes validation, the server trusts the claims in the payload (e.g., user ID) to identify the user.


Access Granted:

If the JWT is valid, the server allows the requested action (e.g., view profile, place an order).

What is Stateless?
In computing, stateless refers to a system or process that does not retain any information (state) about a user's session or previous interactions. Every request from the client is treated as a new, independent request, with no connection to past requests.

Example of Statelessness
Stateless Interaction:

A client sends a request to an API endpoint with a JWT in the header.

The server validates the token, processes the request, and sends back a response.

The server does not keep any information about the client or the request after sending the response.

Each request is independent and complete in itself.

Advantages of Stateless Systems
Scalability:

Since the server doesn't need to store user data, it can handle more clients and scale more easily.

Fault Tolerance:

If one server fails, another can handle the request without requiring shared session data. 




Method-level security in Spring Boot is a way to enforce authorization checks directly at the method level. This provides a more granular level of security than traditional URL-based security, allowing you to apply security policies to specific methods in your service or controller classes based on roles, permissions, or other criteria.

Types of Method-Level Security in Spring Security:
@PreAuthorize: Check the security of the method before it is executed.

@Secured: Declare a role-based access control at the method level.

@PostAuthorize: Check security after the method has been executed.

@RolesAllowed: Similar to @Secured, but more general.

1. @PreAuthorize
Description: The @PreAuthorize annotation is used to specify that security checks should be made before the method is executed. The expression provided in @PreAuthorize defines the conditions under which the method can be invoked. It's typically used to check if a user has the necessary permissions or roles before executing a method.

Usage: You can use SpEL (Spring Expression Language) to define complex security rules, such as checking roles, authorities, or specific attributes of the authenticated user.

Example:


@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(String userId) {
    // Code to delete a user
}
In this example, the deleteUser method will only be executed if the authenticated user has the role ADMIN.

More Complex Example:


@PreAuthorize("hasRole('ADMIN') or #userId == authentication.name")
public void updateUser(String userId, User user) {
    // Code to update user
}
In this case, the method can be executed if the user has the ADMIN role or if the user ID matches the authenticated user's name.

2. @Secured
Description: The @Secured annotation is simpler compared to @PreAuthorize. It allows you to specify a list of roles or authorities that are required to invoke the method. It’s often used when you only need role-based access control and don’t need the flexibility of SpEL expressions.

Usage: You specify roles directly in the annotation as an array of strings.

Example:

@Secured({"ROLE_ADMIN", "ROLE_MANAGER"})
public void createReport() {
    // Code to create a report
}



3. @PostAuthorize
Description: The @PostAuthorize annotation checks the security after the method has been executed. It’s typically used when you want to enforce security based on the result of the method (e.g., if the method returns an object, the security check can be performed on that object).

Usage: @PostAuthorize uses SpEL expressions to evaluate whether the returned result meets the security requirements after the method is executed.

Example:

@PostAuthorize("returnObject.owner == authentication.name")
public User getUserById(String userId) {
    // Code to retrieve a user by ID
    return userService.findUserById(userId);
}
In this example, after the getUserById method executes, Spring Security will check if the owner property of the returned User object matches the authenticated user's name. If not, an AccessDeniedException will be thrown.



4. @RolesAllowed
Description: The @RolesAllowed annotation is similar to @Secured, but it is more general and is part of the JSR-250 specification. It allows you to specify roles or authorities required to invoke a method.

Usage: You list the roles directly in the annotation. Unlike @Secured, @RolesAllowed does not use the ROLE_ prefix by default. It is also more compatible with different security frameworks.

Example:


@RolesAllowed({"ADMIN", "USER"})
public void viewProfile(String userId) {
    // Code to view a user's profile
}
In this example, the viewProfile method can be executed by users with the roles ADMIN or USER.
To use these annotations in Spring, you need to enable method-level security by adding @EnableGlobalMethodSecurity in your configuration class:






When handling expired JWT tokens in a Spring Boot application, I follow a structured approach to ensure both security and usability. Here's how I would explain it during an interview:

Step 1: Check Token Validity
The first step is to validate the JWT in a filter or middleware during each request. This includes verifying:

The token's signature.

The exp (expiration) claim.

If the token is expired, I ensure that the system doesn't reject the request outright but provides a user-friendly mechanism to handle it.

Step 2: Implement Token Expiration Handling
When a JWT is detected as expired, there are two common approaches:

A. Use Refresh Tokens (Best Practice)
Why Refresh Tokens?

Access tokens (JWTs) are typically short-lived for security reasons.

A long-lived refresh token allows users to get a new access token without re-authenticating.

How Refresh Tokens Work?
Here’s how the process works step-by-step:

1. Initial Login
The user logs in using their credentials (e.g., username/password).

The server generates:

An access token (short-lived, e.g., 15 minutes).

A refresh token (long-lived, e.g., 7 days).

The access token is sent in the Authorization header for each API request, and the refresh token is stored securely.

2. When the Access Token Expires
The client detects that the access token has expired (e.g., server returns a 401 Unauthorized response).

Instead of asking the user to log in again, the client sends the refresh token to a specific API endpoint (/refresh) to get a new access token.

3. Server Validates the Refresh Token
The server checks if the refresh token:

Is valid (not tampered with).

Is not expired.

Is not revoked (if token revocation is implemented).

If the refresh token is valid:

The server issues a new access token (and optionally a new refresh token).
  @PostMapping("/refresh-token")
    public ResponseEntity<?> refreshAccessToken(@RequestBody RefreshTokenRequest request) {
        String refreshToken = request.getRefreshToken();

        if (jwtService.validateToken(refreshToken)) {
            String username = jwtService.getUsername(refreshToken);

            // Generate new access token
            String newAccessToken = jwtService.generateAccessToken(username);

            return ResponseEntity.ok(new TokenResponse(newAccessToken, refreshToken));
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid or expired refresh token");
        }
    }
}



4. Client Stores the New Access Token
The new access token replaces the expired one, and the client resumes normal API requests.




3. Example Flow
A user logs in, and their roles (e.g., ADMIN, USER) are encoded in the JWT.

For every request:

The JWT is validated.

Roles are extracted and set in the SecurityContext.

Spring Security checks the user's roles against endpoint requirements.




Role-Based Access Control (RBAC) Implementation in Spring Security with JWT:
User Login & JWT Generation:

When the user logs in (typically with their username and password), the application generates a JWT token. This token contains various claims, one of which is the username, which identifies the user. Other claims can include roles and additional user-specific information.

The JWT token is signed using a secret key (HMAC256 in your case) to ensure its integrity and security. The generated token also has an expiration time to ensure it is valid only for a certain period.

Client Sends JWT Token in Requests:

After login, the client (usually a frontend or mobile app) receives the JWT token and stores it (typically in local storage, session storage, or HTTP-only cookies).

For every subsequent request to the server, the client includes the JWT token in the Authorization header of the HTTP request, typically formatted as Authorization: Bearer <token>.

JWT Validation by the JWTFilter:

On the server side, the incoming request with the JWT token is intercepted by the JWTFilter class. This filter extracts the token from the Authorization header.

The JWTFilter calls the JWTService to validate the token. The token is verified using the HMAC256 algorithm and the predefined issuer.

If the token is valid, the JWTFilter extracts the username from the JWT claims and uses it to load the user’s details (including their roles) from the database. This is done through the UserRepository interface.

Setting Authentication in the SecurityContext:

Once the user’s information (username and roles) is retrieved, the filter creates a UsernamePasswordAuthenticationToken. This token contains the user’s identity and role(s), and it is placed in the SecurityContextHolder.

This step ensures that the user’s identity is now available within the Spring Security context for the rest of the request processing cycle. This authentication information is used later for authorization checks.

Role-based Access Control (RBAC) Using Spring Security:

Now that the user is authenticated, RBAC (Role-Based Access Control) is enforced. In your Spring Security configuration, this is achieved through route-based access control.

You use methods like hasRole("CONTENTMANAGER") to specify which roles are allowed to access certain endpoints. For example, in the SecurityConfig class, only users with the CONTENTMANAGER role can access the /api/v2/cars/add-car endpoint.

When the server processes the request, Spring Security checks if the user’s role (retrieved during the token validation) matches the required role for the specific endpoint.

If the user has the necessary role, they are allowed access to the resource. If not, access is denied with a 403 Forbidden response.

Conclusion of RBAC Implementation:

This setup provides stateless authentication through JWT, ensuring that each request is authenticated and authorized based on the user's identity and roles.

RBAC is implemented effectively using role-specific checks in your Spring Security configuration, ensuring that only users with the appropriate roles can access specific resources in your application.




JWT-based authentication is widely used but comes with specific vulnerabilities. Here are some common ones and ways to mitigate them:

1. Lack of Token Expiration
Vulnerability: Long-lived tokens increase the risk of misuse if they are stolen.

Mitigation:

Use short-lived access tokens (e.g., 15 minutes).

Implement refresh tokens to issue new access tokens securely.

2. Weak Secret Key
Vulnerability: Using a weak or predictable secret key makes the token easy to forge.

Mitigation:

Use a strong, random secret key for signing tokens.

Rotate secret keys periodically to reduce exposure.








Implementing logout functionality in a JWT-based system can be a bit tricky because JWTs are stateless. Unlike session-based authentication, where you can simply invalidate the session on the server, JWTs remain valid until they expire.

Here’s how you can implement logout functionality step by step:

1. Understand the Problem
Once a JWT is issued, the server cannot "revoke" it because it doesn't store the token.

A client can continue using a valid JWT until it expires, even after logging out.

2. Common Solutions
A. Use a Token Blacklist
What It Means:

Maintain a list of "blacklisted" tokens on the server.

When a user logs out, their JWT is added to this list.

For every request, check if the token is blacklisted.








                                       MODULE 2   Car Evaluation Booking for Sellers
How would you handle API rate-limiting to ensure the system isn’t overwhelmed by too many requests from a seller, especially during peak hours?

package cp.service;

import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
public class RateLimiterService {

    // Store user request count and the time when the window started
    private final Map<String, UserRequestInfo> userRequests = new HashMap<>();
    private static final int MAX_REQUESTS = 100; // Max requests per time window
    private static final long TIME_WINDOW = 60000; // 1 minute (60,000 milliseconds)

    // Checks if the user has exceeded the request limit within the time window
    public boolean isRequestAllowed(String userId) {
        long currentTime = System.currentTimeMillis();

        // If the user has no entry or window expired, initialize a new entry
        userRequests.putIfAbsent(userId, new UserRequestInfo(0, currentTime));

        UserRequestInfo userRequestInfo = userRequests.get(userId);

        // If the time window has passed, reset the counter and timestamp
        if (currentTime - userRequestInfo.getTimestamp() > TIME_WINDOW) {
            userRequestInfo.setCount(0);
            userRequestInfo.setTimestamp(currentTime);
        }

        // Check if the user has exceeded the allowed request limit
        if (userRequestInfo.getCount() >= MAX_REQUESTS) {
            return false; // Exceeded rate limit
        }

        // Otherwise, increment the count and allow the request
        userRequestInfo.incrementCount();
        return true;
    }

    // Inner class to store request count and timestamp
    private static class UserRequestInfo {
        private int count;
        private long timestamp;

        public UserRequestInfo(int count, long timestamp) {
            this.count = count;
            this.timestamp = timestamp;
        }

        public int getCount() {
            return count;
        }

        public void setCount(int count) {
            this.count = count;
        }

        public long getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(long timestamp) {
            this.timestamp = timestamp;
        }

        public void incrementCount() {
            this.count++;
        }
    }
}

   

How would you ensure that the notification system (Email, SMS, WhatsApp) is asynchronous so that it doesn't block the main request handling process?
1. Use @Async Annotation in Spring
You can make the sendWhatsAppMessage method in your TwilioService asynchronous by annotating it with @Async. Spring will execute this method in a separate thread, allowing the main request to complete without waiting for the message-sending process.

Updated TwilioService Class:
java
Copy
Edit
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class TwilioService {

    @Value("${twilio.whatsapp.from}")
    private String fromWhatsApp;

    @Async
    public void sendWhatsAppMessage(String to, String messageBody) {
        Message message = Message.creator(
                new PhoneNumber("whatsapp:" + to), // Customer's WhatsApp number
                new PhoneNumber("whatsapp:" + fromWhatsApp), // Your Twilio WhatsApp-enabled number
                messageBody
        ).create();

        System.out.println("Message sent with SID: " + message.getSid());
    }
}
Enabling Async Support:
In your Spring Boot application, enable asynchronous execution by adding the @EnableAsync annotation to your main application class.

java
Copy
Edit
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync
public class YourApplication {
    public static void main(String[] args) {
        SpringApplication.run(YourApplication.class, args);
    }
}
2. Use a Messaging Queue (Optional for Scalability)
If you need more scalability, you can integrate a message broker like RabbitMQ, ActiveMQ, or Kafka to handle notifications. However, since you mentioned you're not using Kafka, this step is optional.

Updated allocate Endpoint with Asynchronous Notification
The updated allocate method remains unchanged, as the @Async annotation ensures that the notification process is non-blocking:

java
Copy
Edit
@PutMapping("/allocate")
public ResponseEntity<String> allocate(@RequestParam int agentid, @RequestParam long cid) {
    Agent agent = agentRepository.findById((long) agentid).orElseThrow(() -> 
        new RuntimeException("Agent not found"));

    CustomerVisit customerVisit = customerVisitRepository.findById(cid).orElseThrow(() -> 
        new RuntimeException("Customer Visit not found"));

    customerVisit.setAgent(agent);
    customerVisitRepository.save(customerVisit);

    // This will now run asynchronously
    twilioService.sendWhatsAppMessage("+917051858967", "Agent has been allocated.");

    return new ResponseEntity<>("Agent allocated successfully", HttpStatus.OK);
}
Advantages of This Approach
Non-Blocking Requests:

The main thread doesn't wait for the notification process to complete, improving request handling speed.

  What Happens Without Asynchronous Processing?
When the sendWhatsAppMessage method is called in your allocate endpoint:

The main thread (handling the HTTP request) waits for the Twilio API call to complete before it can return a response to the client.

If the Twilio API is slow or encounters delays (e.g., network latency, server issues), the client will have to wait longer for the response.

If multiple requests come in simultaneously, all threads may get stuck waiting, reducing the application's capacity to handle more users.






How would you handle retry logic in case a notification fails to send? Would you use a queue system, and if so, how?
1. Without a Queue System: Simple Retry Logic
You can implement retry logic directly in your TwilioService using a loop or a retry library like Spring Retry.

Using Spring Retry
Spring Retry provides an easy way to retry a failed operation.

Add Dependency: Add the Spring Retry dependency in your pom.xml:

xml
Copy
Edit
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
Configure Retry Logic: Annotate the sendWhatsAppMessage method with @Retryable.

java
Copy
Edit
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;

@Service
public class TwilioService {

    @Value("${twilio.whatsapp.from}")
    private String fromWhatsApp;

    @Retryable(
        value = Exception.class,
        maxAttempts = 3,
        backoff = @Backoff(delay = 2000) // Wait 2 seconds between retries
    )
    public void sendWhatsAppMessage(String to, String messageBody) {
        Message message = Message.creator(
            new PhoneNumber("whatsapp:" + to), // Customer's WhatsApp number
            new PhoneNumber("whatsapp:" + fromWhatsApp), // Twilio number
            messageBody
        ).create();

        System.out.println("Message sent with SID: " + message.getSid());
    }
}
Enable Retry: Add @EnableRetry to your main application class.

java
Copy
Edit
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.retry.annotation.EnableRetry;

@SpringBootApplication
@EnableRetry
public class YourApplication {
    public static void main(String[] args) {
        SpringApplication.run(YourApplication.class, args);
    }
}
What Happens?
If sendWhatsAppMessage fails, it will automatically retry up to 3 times with a 2-second delay between attempts.




Interviewer: How do you handle invalid or conflicting date/time selections when sellers book evaluation appointments?

You:

When handling date/time selections for evaluation appointments, it is essential to ensure that the chosen time is both valid and does not conflict with other appointments or system constraints. Here's how I approached this:

Date/Time Validation:

Format Validation: First, I ensured the selected date/time follows the correct format (e.g., ISO 8601) and that it's not in the past. If a seller tries to select a date/time in the past, the API responds with a 400 Bad Request status and a meaningful error message such as:
"Preferred date/time cannot be in the past."

Boundary Checks: I also set boundaries for how far in advance the seller can schedule the evaluation. For example, a seller might only be allowed to book an evaluation within a 30-day window, and I ensure this is checked in the backend. If the date is outside the allowed range, the API returns an error like:
"The evaluation appointment must be scheduled within the next 30 days."

Conflict Detection:

Slot Availability Check: Before finalizing the appointment, I check the availability of the seller's preferred date/time. I compare it with existing appointments in the system for that particular evaluation type (e.g., home visit or online evaluation).

I check the evaluationDateTime field in the database to see if another booking exists for the same seller and evaluation type within a specific time window (e.g., 2-hour buffer).

If there’s a conflict (i.e., another appointment already exists within that time frame), the system responds with a conflict error:

json
Copy
Edit
{
  "message": "The selected date/time is already taken. Please choose a different time.",
  "conflictingAppointmentId": 789
}
In such cases, I allow sellers to either pick a new time or propose a range of alternative available time slots based on system availability.

Time Zone Handling:

To avoid issues with sellers booking appointments across different time zones, I ensured the system handles time zones correctly. I store all times in UTC in the database and convert them to the seller's local time when presenting available slots or confirming a booking. This prevents confusion related to time zone discrepancies.

User-Friendly Feedback:

If the date/time selection is invalid or conflicts with an existing appointment, the system provides user-friendly feedback with suggested next steps. For example, if the seller picks a time that is too close to an existing appointment, the API might respond with:

json
Copy
Edit
{
  "message": "This time is already taken. Would you like to select an alternative time from the available slots?"
}
This approach helps sellers make informed decisions and avoids frustration.

By implementing these checks and providing clear, actionable feedback to sellers, I was able to ensure that date/time selections were both valid and conflict-free, improving the user experience while keeping the scheduling system consistent and reliable.



Did you implement any form of input validation or data sanitization on the inputs from the sellers (e.g., checking the date format or future appointments)?
1. Input Validation
Date Format Validation:
I enforced a specific date format (YYYY-MM-DD) for the input. This was checked both on the client side and in the backend to ensure uniformity. If the format was invalid, the API would return a 400 Bad Request status with a message like:

json
Copy
Edit
{
  "message": "Invalid date format. Please use 'YYYY-MM-DD'."
}
Future Appointments:
I ensured that sellers could only book appointments for future dates. Any attempt to book a past date would result in a 400 Bad Request response with a message like:

json
Copy
Edit
{
  "message": "The appointment date must be in the future."
}






Did you implement any form of input validation or data sanitization on the inputs from the sellers (e.g., checking the date format or future appointments)?
asnwer as interviewee simple words


ChatGPT said:
Yes, I implemented input validation and data sanitization to ensure the inputs from sellers were correct and secure.

Date Format Validation: I used annotations like @DateTimeFormat to ensure the date inputs followed the required format, such as yyyy-MM-dd. This prevented incorrect date formats from being processed.

Future Appointments: I added logic to check if the provided date was in the future and within an allowed range, like within the next 30 days. If the date was invalid, the system returned a clear error message, like "The appointment date must be within the next 30 days."

Sanitization: I used libraries like Hibernate to sanitize inputs, preventing harmful code like SQL injections or scripts. Hibernate and Prepared Statements automatically prevent SQL injection by binding user inputs to query parameters, rather than inserting them directly into SQL.  fo rthis we use parametrized quers


Why These Codes?
200 OK is a standard response when the request is successful.

201 Created is specific for when a new resource is successfully created.

400 Bad Request and 404 Not Found are used to clearly indicate client-side issues or invalid requests.

409 Conflict is ideal for situations where the request cannot be completed due to a conflict with the existing resource state.

500 Internal Server Error is used when there's an unexpected error on the server side.







Interviewer: How did you design the scheduling logic to allow sellers to pick their preferred evaluation date and time, while ensuring there are no conflicts?

You (Interviewee):

To handle scheduling and prevent conflicts, We designed the system to only show available time slots to the sellers. Here’s how I approached it:

Working Hours Definition: I first defined the working hours for car evaluation appointments, for example, from 9 AM to 5 PM.

Get Existing Bookings: Before showing the available time slots to sellers, I queried the database for existing bookings on the selected date to ensure I don’t show any time slots that are already booked.

Generate Available Slots: Based on the working hours, I dynamically generated time slots in hourly intervals (e.g., 9:00 AM, 10:00 AM, etc.) and checked each slot to ensure it wasn’t already taken.

Avoid Conflicts: For each slot, I compared the requested time with the existing bookings. If the time was already occupied, I excluded that slot from the available options.

Display to Seller: Finally, I sent only the available slots to the frontend. The seller could then pick a time slot from the available ones, ensuring there would be no double bookings.

This way, sellers could only choose from time slots that were not already booked, and there was no risk of scheduling conflicts.





You (Interviewee):

To prevent two sellers from booking the same time slot for their car evaluation, I handle it in the following way:

Check Availability First: Before confirming the booking, I check whether the time slot the seller chooses is still available in the system.

Immediate Availability Check: Once the seller picks a time, I quickly check the database to make sure that the slot hasn’t already been booked by someone else in the meantime. If it’s still available, I confirm the booking. If not, I let the seller know the slot is taken and ask them to pick another one.

User-Friendly Message: If the selected slot is no longer available, I show a clear message like: "The time slot you selected is no longer available. Please choose another slot."





1. Create a .env File
In your project's root directory, create a file named .env.

Add your sensitive credentials to this file in KEY=VALUE format.

Example .env file:

plaintext
Copy
Edit
TWILIO_ACCOUNT_SID=your_account_sid_here
TWILIO_AUTH_TOKEN=your_auth_token_here
TWILIO_PHONE_NUMBER=your_phone_number_here
2. Add .env to .gitignore
To prevent the .env file from being accidentally pushed to version control systems (e.g., GitHub), add it to your .gitignore file.

Example .gitignore:

plaintext
Copy
Edit
.env
3. Load Environment Variables in Your Application
For Spring Boot
Add a dependency like spring-dotenv or use the built-in support for environment variables.

Access variables using @Value or System.getenv().

Example:

java
Copy
Edit
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class TwilioConfig {

    @Value("${TWILIO_ACCOUNT_SID}")
    private String accountSid;

    @Value("${TWILIO_AUTH_TOKEN}")
    private String authToken;

    @Value("${TWILIO_PHONE_NUMBER}")
    private String phoneNumber;

    public void initTwilio() {
        System.out.println("Account SID: " + accountSid);
    }
}
Using Spring Boot's application.properties
You can map .env variables to Spring Boot's configuration using application.properties:

properties
Copy
Edit
twilio.accountSid=${TWILIO_ACCOUNT_SID}
twilio.authToken=${TWILIO_AUTH_TOKEN}
twilio.phoneNumber=${TWILIO_PHONE_NUMBER}    




%-------------------------
% Resume in Latex
% Author : Jake Gutierrez
% Based off of: https://github.com/sb2nov/resume
% License : MIT
%------------------------

\documentclass[letterpaper,11pt]{article}

\usepackage{latexsym}
\usepackage[empty]{fullpage}
\usepackage{titlesec}
\usepackage{marvosym}
\usepackage[usenames,dvipsnames]{color}
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage{tabularx}
\usepackage{fontawesome5}
\usepackage{multicol}
\setlength{\multicolsep}{-3.0pt}
\setlength{\columnsep}{-1pt}
\input{glyphtounicode}


%----------FONT OPTIONS----------
% sans-serif
% \usepackage[sfdefault]{FiraSans}
% \usepackage[sfdefault]{roboto}
% \usepackage[sfdefault]{noto-sans}
% \usepackage[default]{sourcesanspro}

% serif
% \usepackage{CormorantGaramond}
% \usepackage{charter}


\pagestyle{fancy}
\fancyhf{} % clear all header and footer fields
\fancyfoot{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% Adjust margins
\addtolength{\oddsidemargin}{-0.6in}
\addtolength{\evensidemargin}{-0.5in}
\addtolength{\textwidth}{1.19in}
\addtolength{\topmargin}{-.7in}
\addtolength{\textheight}{1.4in}

\urlstyle{same}

\raggedbottom
\raggedright
\setlength{\tabcolsep}{0in}

% Sections formatting
\titleformat{\section}{
  \vspace{-4pt}\scshape\raggedright\large\bfseries
}{}{0em}{}[\color{black}\titlerule \vspace{-5pt}]

% Ensure that generate pdf is machine readable/ATS parsable
\pdfgentounicode=1

%-------------------------
% Custom commands
\newcommand{\resumeItem}[1]{
  \item\small{
    {#1 \vspace{-2pt}}
  }
}

\newcommand{\classesList}[4]{
    \item\small{
        {#1 #2 #3 #4 \vspace{-2pt}}
  }
}

\newcommand{\resumeSubheading}[4]{
  \vspace{-2pt}\item
    \begin{tabular*}{1.0\textwidth}[t]{l@{\extracolsep{\fill}}r}
      \textbf{#1} & \textbf{\small #2} \\
      \textit{\small#3} & \textit{\small #4} \\
    \end{tabular*}\vspace{-7pt}
}

\newcommand{\resumeSubSubheading}[2]{
    \item
    \begin{tabular*}{0.97\textwidth}{l@{\extracolsep{\fill}}r}
      \textit{\small#1} & \textit{\small #2} \\
    \end{tabular*}\vspace{-7pt}
}

\newcommand{\resumeProjectHeading}[2]{
    \item
    \begin{tabular*}{1.001\textwidth}{l@{\extracolsep{\fill}}r}
      \small#1 & \textbf{\small #2}\\
    \end{tabular*}\vspace{-7pt}
}

\newcommand{\resumeSubItem}[1]{\resumeItem{#1}\vspace{-4pt}}

\renewcommand\labelitemi{$\vcenter{\hbox{\tiny$\bullet$}}$}
\renewcommand\labelitemii{$\vcenter{\hbox{\tiny$\bullet$}}$}

\newcommand{\resumeSubHeadingListStart}{\begin{itemize}[leftmargin=0.0in, label={}]}
\newcommand{\resumeSubHeadingListEnd}{\end{itemize}}
\newcommand{\resumeItemListStart}{\begin{itemize}}
\newcommand{\resumeItemListEnd}{\end{itemize}\vspace{-5pt}}

%-------------------------------------------
%%%%%%  RESUME STARTS HERE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%----------HEADING----------
% \begin{tabular*}{\textwidth}{l@{\extracolsep{\fill}}r}
%   \textbf{\href{http://sourabhbajaj.com/}{\Large Sourabh Bajaj}} & Email : \href{mailto:sourabh@sourabhbajaj.com}{sourabh@sourabhbajaj.com}\\
%   \href{http://sourabhbajaj.com/}{http://www.sourabhbajaj.com} & Mobile : +1-123-456-7890 \\
% \end{tabular*}

\begin{center}
    {\Huge \scshape Tahir Athir Shah} \\ \vspace{1pt}
    Java Backend Developer \\ \vspace{1pt}
    \small \raisebox{-0.1\height}\faPhone\ +91 70518 58967   ~ \href{mailto:smriti.7377@gmail.com}{\raisebox{-0.2\height}\faEnvelope\  \underline{
    tahirathirshah@gmail.com
    }} ~  \faMapMarker\ Bengaluru, India \\
    \vspace{-8pt}
  
    % \href{https://linkedin.com/in//}{\raisebox{-0.2\height}\faLinkedin\ \underline{linkedin.com/in/username}}  ~
    % \href{https://github.com/}{\raisebox{-0.2\height}\faGithub\ \underline{github.com/username}}
    \vspace{-8pt}
\end{center}

\section*{Summary}
\begin{itemize}[leftmargin=0.15in, label={}]
    \item{
        Experienced Java Backend Developer with over 3 years of experience in building web applications using Spring Boot, MVC Architecture, Spring Security, RESTful APIs, Hibernate ORM, and MySQL. Skilled in designing and implementing robust backend solutions, ensuring scalability and performance in various applications.
    }
    \item{
        Currently exploring and implementing DevOps practices and AWS cloud services, including EC2, S3, RDS, IAM, and VPC. Familiar with Apache Kafka, proficient in version control using Git/GitHub, and experienced in agile development methodologies with JIRA.
    }
\end{itemize}




%-----------TECHNICAL SKILLS-----------
\section{Technical Skills}
\begin{itemize}[leftmargin=0.15in, label={}]
  \small{\item{
    \vspace{1pt}
    \textbf{Languages}{: Core Java, Java 8, SQL.} \\
    \vspace{1pt}
    \textbf{Frameworks and Libraries}{: Spring Boot, Spring MVC, Spring Data JPA, Hibernate ORM.} \\
    \vspace{1pt}
    \textbf{Databases}{: MySQL, Relational Databases} \\
    \vspace{1pt}
    \textbf{Cloud Services}{: Amazon Web Services (AWS) , Pre-signed URLs, Cloud Storage.} \\
    \vspace{1pt}
    \textbf{DevOps and CI/CD}{: Jenkins, Maven, Git, GitHub, Deployment Automation.} \\
    \vspace{1pt}
    \textbf{Development Practices}{: RESTful API Development, Microservices, MVC Architecture, Agile (Scrum), Version Control.} \\
    \vspace{1pt}
    \textbf{Security}{: JWT, RBAC, Spring Security, BCrypt, OTP Authentication.} \\
    \vspace{1pt}
    \textbf{Tools and Platforms}{: IntelliJ IDEA, Postman, Kafka, Swagger} \\
    \vspace{1pt}
    \textbf{Skills}{: Backend Development, API Integration} \\
    \vspace{1pt}
    \textbf{Soft Skills}{: Communication, Team Collaboration, Problem Solving, Conflict Resolution, Adaptability.} \\
  }}
\end{itemize}
\vspace{-16pt}


% %------RELEVANT COURSEWORK-------
% \section{Relevant Coursework}
%     %\resumeSubHeadingListStart
%         \begin{multicols}{4}
%             \begin{itemize}[itemsep=-5pt, parsep=3pt]
%                 \item\small Data Structures
%                 \item Software Methodology
%                 \item Algorithms Analysis
%                 \item Database Management
%                 \item Artificial Intelligence
%                 \item Internet Technology
%                 \item Systems Programming
%                 \item Computer Architecture
%             \end{itemize}
%         \end{multicols}
%         \vspace*{2.0\multicolsep}
%     %\resumeSubHeadingListEnd


%-----------EXPERIENCE-----------
\section{Experience}
  \resumeSubHeadingListStart

    \resumeSubheading
      {Java Backend Developer}{September 2024 -- Present}
      {Soliton Technologies.}{}
      \resumeItemListStart
      \resumeItem{Designed and implemented an \textbf{MVC architecture} using Java, Spring Boot and MySQL, demonstrating expertise in backend development}
        \resumeItem{Implemented robust RBAC for API endpoints using \textbf{Spring Security} and JWT, integrating user \textbf{authentication} and \textbf{authorization} mechanisms to ensure secure access.}
        \resumeItem{Integrated AWS S3 for secure storage of car images, providing reliable access through public URLs.}
      \resumeItem{Utilized Spring MVC for mapping HTTP requests and designing endpoints following standard HTTP methods (GET, POST, PUT, DELETE).}
      \resumeItemListEnd

    \resumeSubheading
      {Technical advisor} {April 2024 - August 2024}
      {Concentrix 
}{}
      \resumeItemListStart
        \resumeItem{Contributed to the Backend development as a key team member, utilizing Spring Boot 3 and Spring Security 6. Integrated JWT-based authentication under senior guidance, ensuring secure admin and customer access.}
        \resumeItem{Implemented MVC architecture to design modular and scalable backend components, improving code maintainability and fostering team collaboration.}
        % \resumeItem{Collaborated with team members using version control systems such as Git to organize modifications and assign tasks.}
    \resumeItemListEnd
     \resumeSubheading
      {Junior Java Developer} {April 2022 --  March 2024}
      {ScalaCode}{}
      \resumeItemListStart
        \resumeItem{Contributed to the development of backend services and APIs using Java and related technologies, under the guidance of senior developers, to support the company's software products.}
        \resumeItem{Actively engaged in learning and professional development activities, such as attending training sessions and workshops, to enhance skills and knowledge in Java development.}
        \resumeItem{Implemented Spring Data JPA and \textbf{Hibernate} for efficient database management, designing entity classes, creating repositories for CRUD operations, and writing JPQL queries, ensuring data integrity and efficiency.}
        \resumeItem{Developed and integrated \textbf{RESTful APIs} in collaboration with the front-end team, resulting in a 20\% boost in user satisfaction.}
        \resumeItem{Built comprehensive product management functionality, allowing admins to post, update, and delete products
efficiently}
    \resumeItemListEnd
    
  \resumeSubHeadingListEnd
\vspace{-16pt}


% %-----------PROJECTS-----------
% \section{Projects}
%     \vspace{-5pt}
%     \resumeSubHeadingListStart
%       \resumeProjectHeading
%           {\textbf{Gym Reservation Bot} $|$ \emph{Python, Selenium, Google Cloud Console}}{January 2021}
%           \resumeItemListStart
%             \resumeItem{Developed an automatic bot using Python and Google Cloud Console to register myself for a timeslot at my school gym.}
%             \resumeItem{Implemented Selenium to create an instance of Chrome in order to interact with the correct elements of the web page.}
%             \resumeItem{Created a Linux virtual machine to run on Google Cloud so that the program is able to run everyday from the cloud.}
%             \resumeItem{Used Cron to schedule the program to execute automatically at 11 AM every morning so a reservation is made for me.}
%           \resumeItemListEnd
%           \vspace{-13pt}
%       \resumeProjectHeading
%           {\textbf{Ticket Price Calculator App} $|$ \emph{Java, Android Studio}}{November 2020}
%           \resumeItemListStart
%             \resumeItem{Created an Android application using Java and Android Studio to calculate ticket prices for trips to museums in NYC.}
%             \resumeItem{Processed user inputted information in the back-end of the app to return a subtotal price based on the tickets selected.}
%             \resumeItem{Utilized the layout editor to create a UI for the application in order to allow different scenes to interact with each other.}
%           \resumeItemListEnd 
%           \vspace{-13pt}
%           \resumeProjectHeading
%           {\textbf{Transaction Management GUI} $|$ \emph{Java, Eclipse, JavaFX}}{October 2020}
%           \resumeItemListStart
%             \resumeItem{Designed a sample banking transaction system using Java to simulate the common functions of using a bank account.}
%             \resumeItem{Used JavaFX to create a GUI that supports actions such as creating an account, deposit, withdraw, list all acounts, etc.}
%             \resumeItem{Implemented object-oriented programming practices such as inheritance to create different account types and databases.}
%           \resumeItemListEnd 
%     \resumeSubHeadingListEnd
% \vspace{-15pt}


%
%-----------EDUCATION-----------
\section{Education}
  \resumeSubHeadingListStart
    \resumeSubheading
      {University of Kashmir}{2020 -- 2023}
      {Bachelor of Computer Application  (BCA)}{}
  \resumeSubHeadingListEnd
%-----------PROJECTS-----------
\section{Projects}
\resumeSubHeadingListStart

  \resumeProjectHeading
    {\textbf{TrueCar} $|$ \emph{Java, Spring Boot, Spring Security, Hibernate, MySQL, AWS (S3, EC2), JWT, Twilio, Maven}}{Oct 2024 – Present}

    % First module: User Authentication & Authorization Module
    \vspace{2pt}
    \textbf{1. User Authentication \& Authorization}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Integrated \textbf{Spring Security} with \textbf{JWT} (JSON Web Tokens) for secure, stateless authentication across all user-related APIs, ensuring that each request is authenticated and authorized before access.}
      \resumeItem{Implemented \textbf{role-based access control (RBAC)} to define user roles (Admin, Evaluation Executive, CRM Team, and Customer) and provide appropriate access levels to various resources and functionalities.}
      \resumeItem{Configured \textbf{password encryption using BCrypt} to ensure sensitive data protection during user login and registration processes.}
      \resumeItem{Developed role-based endpoint access to restrict specific API routes based on user roles, ensuring only authorized users can perform specific actions.}
      \resumeItem{Integrated \textbf{JWT expiration handling} to enhance security by automatically invalidating expired tokens.}
      \resumeItem{Improved system security by implementing \textbf{CORS (Cross-Origin Resource Sharing)} policies to restrict access from unauthorized domains.}
    \resumeItemListEnd

    % Second module: Car Evaluation Booking
    \vspace{2pt}
    \textbf{2. Car Evaluation Booking}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Built \textbf{REST APIs} to facilitate car evaluation appointment requests.}
      \resumeItem{Provided flexible scheduling options, enabling sellers to choose their preferred evaluation date and time.}
      \resumeItem{Implemented a multi-channel notification system using \textbf{Twilio} (SMS and WhatsApp) to confirm booking appointments.}
    \resumeItemListEnd

    % Third module: Car Listing & Inventory Management
    \vspace{2pt}
    \textbf{3. Listing \& Inventory Management}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Developed REST APIs to efficiently manage vehicle listings, supporting operations such as addition, updates, filtering, and deletion for streamlined inventory management.}
      \resumeItem{Integrated \textbf{AWS S3} for secure photo uploads, enabling reliable storage and access to car images via public URLs.}
      \resumeItem{Handled photo uploads by integrating AWS S3 – stored car images securely and returned public access URLs in response.}
      \resumeItem{Added metadata handling and linked image URLs to each car in the database.}
    \resumeItemListEnd

    % Fourth module: Booking & Test Drive Scheduling
    \vspace{2pt}
    \textbf{4. Booking \& Test Drive Scheduling}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Built APIs for test drive requests, availability checking, and booking confirmation.}
      \resumeItem{Sent real-time confirmations via email, SMS, and WhatsApp using third-party services.}
    \resumeItemListEnd

    % Fifth module: Search & Filtering
    \vspace{2pt}
    \textbf{5. Search \& Filtering}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Developed APIs to search vehicles by price range, brand, mileage, and other attributes.}
      \resumeItem{Implemented pagination and sorting to enhance the user experience and reduce server load.}
    \resumeItemListEnd

    % Sixth module: API Testing & Documentation with Swagger
    \vspace{2pt}
    \textbf{6. API Testing \& Documentation with Swagger}
    \vspace{2pt}
    \resumeItemListStart
      \resumeItem{Implemented \textbf{Swagger UI} for interactive API documentation, simplifying exploration with detailed specifications and response models.}
      \resumeItem{Performed thorough API testing using \textbf{JUnit} and \textbf{Mockito}, ensuring functionality, stability, and backward compatibility.}
    \resumeItemListEnd

\resumeSubHeadingListEnd


%
\end{document}



